# Chapter 13: Writing Effective Comments in Software Design

## Description

This chapter outlines principles for writing comments that enhance code clarity by describing information not obvious from the code itself. It emphasizes that comments should capture the developer's intent, clarify abstractions, and provide both low-level precision and high-level intuition. The chapter addresses common pitfalls, such as repeating code or including implementation details in interface comments, and provides guidance on commenting conventions, variable documentation, and handling cross-module design decisions. Additional real code block examples illustrate effective commenting practices.

## 13.1 Pick Conventions

- **Establish Commenting Conventions**: Decide what to comment and the format, ideally aligning with tools like Javadoc, Doxygen, or godoc for consistency.
- **Adopt Existing Standards**: If no conventions exist, use those from similar languages/projects to ease adoption by other developers.
- **Purpose of Conventions**:
  - Ensure consistency for easier reading and understanding.
  - Encourage consistent comment writing to avoid missing documentation.
- **Comment Categories**:
  - **Interface**: Precedes module declarations (e.g., classes, methods) to describe their purpose and behavior.
  - **Data Structure Member**: Next to fields (e.g., class variables) to clarify their role.
  - **Implementation**: Inside methods to explain internal workings.
  - **Cross-Module**: Describes dependencies across modules (rare but critical).
- **Commenting Priority**: Every class, class variable, and method should have interface comments; implementation and cross-module comments are less frequent.

## 13.2 Don’t Repeat the Code

- **Avoid Redundant Comments**: Comments that restate code add no value and can be written without understanding the code.
  - **Poor Example**:
    ```java
    // Set the user's age to 25
    user.age = 25;
    ```
    This comment repeats the code and provides no additional insight.
- **Red Flag: Comment Repeats Code**: Using the same words as the code (e.g., method/variable names) indicates low value.
  - **Poor Example**:
    ```java
    /*
     * Get user ID from request
     */
    private String getUserId(HttpRequest req) { ... }
    ```
    This comment restates the method name and parameter without adding meaning.
- **Provide New Information**: Comments should clarify meaning (e.g., units, purpose) not deducible from code.
  - **Better Example**:
    ```java
    /*
     * The amount of blank space to leave on the left and right sides of each line of text, in pixels.
     */
    private static final int textHorizontalPadding = 4;
    ```
    This clarifies units and scope of padding.

## 13.3 Lower-Level Comments Add Precision

- **Purpose**: Provide detailed clarifications for variable declarations (e.g., class variables, method arguments, return values) to make their meaning precise.
- **Details to Include**:
  - Units (e.g., pixels, characters).
  - Boundary conditions (inclusive/exclusive).
  - Meaning of null values.
  - Responsibility for resource management (e.g., freeing/closing).
  - Invariants (e.g., “this list always contains at least one entry”).
- **Avoid Vague Comments**:
  - **Poor Example**:
    ```java
    // Current offset in buffer
    uint32_t offset;
    ```
    Unclear what “current” means.
  - **Better Example**:
    ```java
    /*
     * Position in this buffer of the first byte that hasn't been returned to the client, in bytes.
     */
    uint32_t offset;
    ```
    Specifies the exact role and unit.
- **Focus on Nouns, Not Verbs**: Describe what a variable represents, not how it’s manipulated.
  - **Poor Example**:
    ```java
    /*
     * Toggled to true when a valid session is created, false when session expires.
     */
    private boolean isSessionActive;
    ```
    Focuses on manipulation.
  - **Better Example**:
    ```java
    /*
     * True if the session is currently active and can accept requests; false if expired or not initialized.
     */
    private boolean isSessionActive;
    ```
    Describes the variable’s meaning.

## 13.4 Higher-Level Comments Enhance Intuition

- **Purpose**: Offer a high-level, abstract view of code to explain intent, purpose, or structure, omitting low-level details.
- **Common Uses**: Method interface comments and comments inside methods (e.g., before loops or code blocks).
- **Example Improvement**:
  - **Poor Example**:
    ```java
    // If user is authenticated, grant access
    if (user.isAuthenticated()) {
        grantAccess(user);
    }
    ```
    Repeats the code’s condition.
  - **Better Example**:
    ```java
    /*
     * Authorize user access to the system if their credentials have been verified.
     */
    if (user.isAuthenticated()) {
        grantAccess(user);
    }
    ```
    Explains the purpose and context.
- **Why Comments**: Explain why code exists (e.g., conditions triggering a method).
  - **Example**:
    ```java
    /*
     * Retry the network request if the server is temporarily unavailable to ensure reliable communication.
     */
    while (attempts < MAX_RETRIES && !isServerAvailable()) {
        try {
            sendRequest();
            break;
        } catch (ServerUnavailableException e) {
            attempts++;
            Thread.sleep(RETRY_DELAY_MS);
        }
    }
    ```
    Clarifies the purpose of retry logic.

## 13.5 Interface Documentation

- **Role in Abstractions**: Interface comments define abstractions by providing a simplified view of a class/method, hiding implementation details.
- **Separate Interface from Implementation**:
  - Interface comments describe what users need to use a module.
  - Implementation comments explain internal workings (for maintainers).
- **Class Interface Comments**:
  - **Example**:
    ```java
    /*
     * This class manages a thread-safe queue for processing asynchronous tasks, ensuring tasks are executed in FIFO order.
     */
    public class TaskQueue { ... }
    ```
    Describes the abstraction without implementation details.
- **Method Interface Comments**:
  - Start with high-level behavior description.
  - Precisely document arguments, return values, side effects, exceptions, and preconditions.
  - **Example**:
    ```java
    /*
     * Copies a range of bytes from this buffer to an external array.
     * @param offset Starting index in the buffer (inclusive, in bytes).
     * @param length Number of bytes to copy.
     * @param dest Array to copy bytes into; must have space for at least length bytes.
     * @return Number of bytes copied; less than length if the range exceeds buffer size; 0 if no overlap.
     * @throws IllegalArgumentException if offset or length is negative.
     */
    public int copyBytes(int offset, int length, byte[] dest) { ... }
    ```
    Provides all necessary usage information.
- **Red Flag: Implementation Documentation Contaminates Interface**: Including implementation details in interface comments exposes unnecessary complexity.

## 13.6 Implementation Comments: What and Why, Not How

- **Purpose**: Explain what code blocks do and why they exist, not how they work, as code shows the “how.”
- **When Needed**: Only for longer or complex methods; short methods often need no implementation comments.
- **Block-Level Comments**:
  - **Example**:
    ```java
    /*
     * Phase 1: Validate user input before processing to prevent invalid data propagation.
     */
    if (!isValidInput(input)) {
        throw new IllegalArgumentException("Invalid input format");
    }
    ```
    Describes the block’s purpose abstractly.
- **Loop Comments**:
  - **Example**:
    ```java
    /*
     * Each iteration processes one batch of records to update the cache.
     */
    for (Record record : batch) {
        cache.update(record.getKey(), record.getValue());
    }
    ```
    Explains the loop’s purpose.
- **Why Comments**:
  - **Example**:
    ```java
    /*
     * Workaround for issue #123: Force flush to ensure data is written before closing the stream.
     */
    outputStream.flush();
    ```
    Explains why the flush is needed, referencing a bug report.
- **Variable Comments**:
  - **Example**:
    ```java
    /*
     * Tracks the number of active connections; used across multiple methods to enforce connection limits.
     */
    private int activeConnections;
    ```
    Documents a variable used over a large code span.

## 13.7 Cross-Module Design Decisions

- **Challenge**: Some design decisions affect multiple modules (e.g., network protocols), but there’s often no obvious place for documentation.
- **Centralized Documentation**:
  - **Example**:
    ```c
    typedef enum Status {
        STATUS_OK = 0,
        STATUS_UNKNOWN_TABLET = 1,
        STATUS_WRONG_VERSION = 2,
        ...
        STATUS_MAX_VALUE = 30,
        /*
         * To add a new status value, update:
         * (1) STATUS_MAX_VALUE to match the largest status value.
         * (2) "messages" and "symbols" tables in Status.cc.
         * (3) ClientException.h with a new exception class.
         * (4) ClientException::throwException with a new case.
         */
    }
    ```
    Lists cross-module dependencies at the enum declaration.
- **Central File Approach**: Use a `designNotes` file with labeled sections (e.g., “Zombies”).
  - **Example**:
    ```java
    /*
     * See "Zombies" in designNotes for handling servers incorrectly marked as crashed.
     */
    if (server.isZombie()) {
        rejectRequest(server);
    }
    ```
    References centralized documentation.
- **Avoid Duplication**: Duplicating cross-module documentation across files is error-prone and hard to maintain.

## 13.8 Conclusion

- **Goal**: Make system structure and behavior obvious, enabling quick, confident modifications.
- **Key Principle**: Comments should describe non-obvious information from the perspective of a first-time code reader.
- **Mindset**: Consider what a reader needs to know; clarify confusion identified in code reviews with better comments or code.
