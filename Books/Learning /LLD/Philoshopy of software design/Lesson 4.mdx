# Chapter 4 — Modules Should Be Deep

## 1. Why Modular Design Matters

When building software, you want developers to **only think about a small part of the system at any given time**.  
This is called **modular design**.

**A module** can be:

- A **class**
- A **function**
- A **microservice**
- A **subsystem** in a larger application

In an ideal world:

- Modules are **independent**
- You can work on one without touching the others

In reality:

- Modules **depend** on each other
- If one changes, others may break

The **goal** of modular design:

1. Minimize dependencies between modules
2. Make dependencies **clear and obvious**

---

## 2. Interface vs. Implementation

Every module has two sides:

1. **Interface** → How other code interacts with it

   - Public methods, parameters, return values, and usage rules
   - Example: `"Call login() before fetchUserData()"`

2. **Implementation** → How it works internally
   - Hidden from other code
   - Can change without affecting others if the interface stays the same

### Example: Balanced Tree (JavaScript)

```js
class BalancedTree {
  insert(key, value) {}
  remove(key) {}
  find(key) {}
}
```

- **Interface**: Just `insert`, `remove`, `find`
- **Implementation**: Complex balancing logic, rotations, node rearrangements — **hidden** from users

---

## 3. Abstractions

An **abstraction** is a **simplified view** of something complex.  
We use abstractions so we **don’t need to think about all the details all the time**.

- **Good abstraction** → Hides unimportant details
- **Bad abstraction** →
  - Includes unnecessary details → increases complexity
  - Hides important details → causes confusion

### Example: File System (Node.js)

```js
const fs = require("fs");

// Simple abstraction
fs.writeFileSync("data.txt", "Hello World");

// Internally handles:
// - Opening file handles
// - Allocating disk blocks
// - Writing data to disk
```

We don’t care **how** it stores data on disk — the abstraction handles it.  
But we do care **when** the file is actually saved — important for databases.

---

## 4. Deep vs. Shallow Modules

### Deep Modules

- **Small interface**
- Hides **a lot of complexity**
- Lets you do **a lot** with minimal knowledge

**Example: Fetch API**

```js
const res = await fetch("https://api.example.com/data");
const data = await res.json();
```

Internally handles:

- HTTP requests
- Redirects
- Network errors
- JSON parsing

### Shallow Modules

- Interface complexity ≈ Implementation complexity
- Doesn’t hide much
- Adds **extra things to learn** without benefit

**Example: Pointless Wrapper**

```js
function addNullValueForAttribute(data, attribute) {
  data[attribute] = null;
}
```

- No hidden complexity
- Easier to just do:

```js
data[attribute] = null;
```

---

## 5. Red Flag: Classitis

**Classitis** = When developers create **too many tiny classes** instead of **fewer, deeper ones**.

Why it’s bad:

1. **Too many interfaces to learn**
2. **Scattered logic** → You have to jump through files to follow a feature
3. **Boilerplate overload**
4. **No real complexity hidden**

### Example: Classitis in File I/O

```js
class FileOpener {
  constructor(fileName) {
    this.fileName = fileName;
  }
  open() {
    return require("fs").readFileSync(this.fileName);
  }
}

class BufferedReader {
  constructor(fileData) {
    this.fileData = fileData;
  }
  read() {
    return this.fileData.toString("utf-8");
  }
}

class JsonParser {
  constructor(rawData) {
    this.rawData = rawData;
  }
  parse() {
    return JSON.parse(this.rawData);
  }
}

// Usage
const fileOpener = new FileOpener("data.json");
const bufferedReader = new BufferedReader(fileOpener.open());
const parser = new JsonParser(bufferedReader.read());
const data = parser.parse();
```

- Four steps for one task
- Must remember the **correct sequence**
- Most classes just pass data around — **no real abstraction**

---

## 6. Better Approach

### Deep Module Way

Instead of splitting tiny responsibilities into separate classes, **hide all the complexity** in one deep module.

#### Better Example: File JSON Reader

```js
class FileHelper {
  static readJson(fileName) {
    const fs = require("fs");
    const raw = fs.readFileSync(fileName, "utf-8"); // Open + read + buffer
    return JSON.parse(raw); // Parse JSON
  }
}

// Usage
const data = FileHelper.readJson("data.json");
```

Benefits:

- One method for the **common case**
- Internally handles:
  - File opening
  - Buffering
  - Parsing JSON
- Still allows advanced cases when needed

#### Better Example: Deep API Client

**Classitis way:**

```js
class HttpRequest {}
class JsonResponse {}
class Authenticator {}
```

Too many moving parts.

**Deep module way:**

```js
class ApiClient {
  constructor(baseUrl, token) {
    this.baseUrl = baseUrl;
    this.token = token;
  }

  async getJson(path) {
    const res = await fetch(`${this.baseUrl}${path}`, {
      headers: { Authorization: `Bearer ${this.token}` },
    });
    return res.json();
  }
}

// Usage
const api = new ApiClient("https://api.example.com", "my-token");
const users = await api.getJson("/users");
```

Benefits:

- One clear method for the **common case**
- Hides:
  - URL building
  - Authentication headers
  - HTTP request sending
  - JSON parsing

---

## 7. Principles for Deep Modules

1. **Fewer modules, deeper logic**
   - Don’t split unnecessarily — each module should hide real complexity
2. **Common case easy, special cases possible**
   - Make the default path simple
   - Still allow advanced usage without breaking abstraction
3. **Interfaces matter more than implementation**
   - A great module is measured by how simple it is to use, not how short the code is inside

---

## 8. Conclusion

- **Deep modules** → Small, simple interface hiding a lot of complexity
- **Shallow modules** → More interface complexity than they remove
- Avoid **Classitis** — don’t create classes for the sake of it
- Always design so that **most developers can do most tasks with the smallest amount of knowledge possible**

✅ **Key takeaway**:

> A **deep module** is like a great tool: simple to use, powerful under the hood, and hard to misuse.
