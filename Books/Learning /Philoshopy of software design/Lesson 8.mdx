# Chapter 8 — Pull Complexity Downwards (Detailed Guide)

## Core Principle

When you build a module and face unavoidable complexity, you have two choices:

1. **Push complexity up** → Let the _user_ of your module handle it.
2. **Pull complexity down** → Hide it _inside_ your module.

You should almost always **pull complexity down** if:

- The complexity is closely related to the functionality your module provides.
- Hiding it will make life easier for _all_ users of the module.
- It keeps your interface **simple** even if your implementation gets harder.

💡 **Key idea:** It’s usually better for a _few developers_ (you, the module author) to suffer than for _every single user_ of your module to suffer.

---

## 8.1 Example — Text Editor Class

### Bad Example — Push Complexity Up

```js
// Line-based API — easy for you, hard for the caller
class TextBuffer {
  insertLine(index, line) {
    /* store a line */
  }
  deleteLine(index) {
    /* remove a whole line */
  }
}
```

**Why it’s bad:**

- User interface code **never** works only with full lines.
- To insert a single character, the UI must:
  1. Split the line.
  2. Insert a new string segment.
  3. Merge it back.
- All UI developers must duplicate this messy logic.

### Better Example — Pull Complexity Down

```js
// Character-based API — harder for you, easier for the caller
class TextBuffer {
  insert(position, text) {
    /* internally splits/merges lines */
  }
  delete(start, end) {
    /* internally merges lines */
  }
}
```

**Why it’s better:**

- Callers can insert/delete anywhere without worrying about line boundaries.
- Splitting/merging logic lives **inside** the text buffer.
- UI developers work with **simple, predictable methods**.

**Trade-off:**

- Your implementation is more complex.
- But **every** caller gets a simpler, cleaner API.

---

## 8.2 Example — Configuration Parameters

A **common mistake** is to push complexity upward by exposing too many configuration parameters.

### Bad Example — Push Up Complexity

```js
class NetworkClient {
  constructor({ retryIntervalMs }) {
    this.retryIntervalMs = retryIntervalMs; // user must guess!
  }

  send(request) {
    setTimeout(() => this.resend(request), this.retryIntervalMs);
  }
}
```

**Problems:**

- Every user must figure out a “good” retry interval.
- Most won’t know the optimal value.
- If conditions change (slow network), their value may become wrong.

### Better Example — Pull Down Complexity

```js
class NetworkClient {
  constructor() {
    this.retryIntervalMs = 1000; // sensible default
    this.dynamicAdjust = true;
  }

  send(request) {
    const start = Date.now();
    this._doSend(request).then(() => {
      const latency = Date.now() - start;
      if (this.dynamicAdjust) {
        this.retryIntervalMs = Math.max(latency * 2, 500);
      }
    });
  }
}
```

**Why it’s better:**

- Module computes a reasonable retry interval automatically.
- Adjusts dynamically to network conditions.
- Users only override in **rare** cases.

### Rule of Thumb

Before adding a configuration parameter, ask:

- _Can we compute this automatically?_
- _Will the user really choose a better value than us?_

---

## 8.3 Taking It Too Far

**Pulling complexity down** is good, but **don’t overdo it**.

### Bad Overreach

```js
// Trying to handle *UI-specific* behavior inside text class
class TextBuffer {
  backspace(cursor) {
    /* tries to mimic backspace key */
  }
}
```

**Why it’s bad:**

- Backspace handling is **UI-specific**.
- Doesn’t really simplify the UI much.
- Creates **information leakage** (text class now depends on UI behavior).

### Better

```js
// Keep TextBuffer generic
class TextBuffer {
  insert(position, text) {
    /* generic insert */
  }
  delete(start, end) {
    /* generic delete */
  }
}

// UI layer decides how backspace works
editor.onBackspace(() => {
  const start = cursor - 1;
  buffer.delete(start, cursor);
});
```

**Why it’s better:**

- TextBuffer stays **UI-agnostic**.
- Higher-level code still simple, but without polluting lower-level logic.

---

## 8.4 Guidelines for Pulling Complexity Down

1. **Do it when:**

   - The complexity belongs naturally with your module’s responsibility.
   - It will significantly simplify code in _many_ other places.
   - It leads to a simpler API for your module.

2. **Avoid it when:**
   - The complexity is specific to a higher layer (UI, business rules).
   - It couples your module to unrelated details.
   - It bloats your module without reducing complexity elsewhere.

---

## 8.5 Key Takeaways

- Prefer **simple interface + complex implementation** over the reverse.
- **Hide complexity inside** the module if it belongs to its core responsibility.
- **Avoid dumping problems** on every user of your API.
- Minimize **configuration parameters** — compute good defaults instead.
- **Don’t pull unrelated complexity** into your module just for the sake of it.
