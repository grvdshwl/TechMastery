# Chapter 9: Better Together or Better Apart?

This chapter tackles a critical decision in software design: **Should two pieces of code live together in the same module, or should they be separated into distinct components?** This choice isn’t about personal preference—it’s about **reducing system complexity**, making code easier to maintain, and preventing subtle bugs. We’ll explore when to **merge** functionality (to keep related knowledge together) and when to **separate** it (to preserve clarity and flexibility). The goal is to create software that’s intuitive, reusable, and robust.

---

## 9.1 Bring Together if Information is Shared

When two parts of a system rely on the **same domain knowledge**, combining them into one module is often better. Keeping them separate can lead to:

- **Information leakage**: Details from one module must be exposed to the other, making the system harder to understand.
- **Duplication**: The same logic or assumptions appear in multiple places, increasing the risk of inconsistencies.

### Example: HTTP Request Reading and Parsing
Consider a system that reads and parses HTTP requests from a network socket. A poor design might separate reading the raw data from parsing it:

```java
// ❌ Bad: Separate reading and parsing
String rawRequest = readFromSocket(socket);
ParsedRequest req = parseRequest(rawRequest);
```

**Problem**: Both `readFromSocket` and `parseRequest` need to understand the structure of an HTTP request (e.g., headers, body, or chunked encoding). If the HTTP standard changes (e.g., new header rules), you must update both functions, which risks errors if one is missed.

**Better Approach**: Combine reading and parsing into a single function:

```java
// ✅ All HTTP knowledge is in one place
HttpRequest req = HttpRequest.fromSocket(socket);
```

**Why it’s better**:
- All HTTP-related knowledge is centralized in one place.
- Changes to HTTP parsing (e.g., handling new formats) are made in a single location.
- The API is simpler and harder to misuse, as users don’t need to call two functions.

**When to apply**: Merge functionality when both parts require deep understanding of the same domain. This reduces duplication, minimizes errors, and keeps the system cohesive.

**Real-world analogy**: Imagine a chef (parser) and a shopper (reader) preparing a meal. If both need to know the recipe (HTTP structure), it’s better to have one person handle both tasks to avoid miscommunication.

---

## 9.2 Bring Together if it Simplifies the Interface

Separating functionality can sometimes force users to deal with unnecessary complexity. Merging related functionality can create a **simpler, more intuitive API**.

### Example: Java I/O Streams
In Java, reading from a file often requires combining multiple classes:

```java
InputStream in = new BufferedInputStream(new FileInputStream("file.txt"));
```

- `FileInputStream` reads raw bytes from a file.
- `BufferedInputStream` adds buffering to improve performance.

**Problem**: Most developers always want buffering for efficiency, but Java forces them to explicitly wrap the `FileInputStream` in a `BufferedInputStream`. This exposes internal details (buffering) that users shouldn’t need to think about.

**Better Approach**: If buffering were built into `FileInputStream` by default, the API would be simpler:

```java
InputStream in = new FileInputStream("file.txt"); // Buffering included
```

**Why it’s better**:
- Users don’t need to understand or manage buffering.
- The API is more intuitive, reducing the chance of mistakes (e.g., forgetting to add buffering).
- It hides implementation details, making the interface deeper (more functionality with less complexity).

**When to apply**: Merge functionality when separation forces users to handle details that could be managed internally. This is especially true when the separate components are almost always used together.

**Real-world analogy**: When you buy a smartphone, you don’t want to separately purchase and install the battery. A simpler design includes the battery, so you just use the phone.

---

## 9.3 Bring Together to Eliminate Duplication

If the same logic appears in multiple places, it’s a sign that functionality should be merged. Duplication causes:
- **Maintenance headaches**: Changes must be made in multiple places, increasing the chance of errors.
- **Inconsistent behavior**: If one instance of the logic is updated but others are missed, the system may behave unpredictably.

### Example: Error Cleanup
Consider a function with multiple error checks that repeat cleanup logic:

```java
// ❌ Bad: Duplicate cleanup
if (error) { cleanup(); return; }
if (otherError) { cleanup(); return; }
```

**Problem**: The `cleanup` call is duplicated, making the code harder to maintain. If `cleanup` changes, you must update every instance.

**Better Approach**: Consolidate the logic:

```java
// ✅ Better: Single cleanup location
if (error || otherError) {
    cleanup();
    return;
}
```

**Why it’s better**:
- Reduces the surface area for bugs by having one cleanup point.
- Makes future changes easier, as you only update one spot.
- Keeps the code concise and easier to read.

**When to apply**: Merge functionality when you notice repeated code or logic. This ensures consistency and simplifies maintenance.

**Real-world analogy**: If you’re cleaning a house and need to vacuum multiple rooms, you don’t buy a separate vacuum for each room. One vacuum (shared logic) does the job.

---

## 9.4 Separate General-Purpose and Special-Purpose Code

**General-purpose code** is reusable across many contexts, while **special-purpose code** is tied to a specific use case. Mixing them:
- Makes the general-purpose code harder to reuse.
- Creates unnecessary dependencies between components.

### Example: Text Editor
In a text editor:
- **General-purpose**: Code for inserting or deleting text in a buffer (usable in many contexts, like a server or command-line tool).
- **Special-purpose**: Code for handling keyboard input, like deleting selected text when the backspace key is pressed.

**Problem**: If you mix these, the core text-editing code depends on keyboard handling, making it impossible to reuse in a non-UI context (e.g., a server-based text processor).

**Better Approach**: Keep them separate:
- A `TextBuffer` class handles inserting/deleting text.
- A `KeyboardHandler` class manages user input and calls `TextBuffer` methods.

**Why it’s better**:
- The `TextBuffer` class is reusable in any context that needs text manipulation.
- The `KeyboardHandler` can evolve independently without affecting core functionality.
- Reduces dependencies, making the system more modular.

**When to apply**: Separate general-purpose “engine” code from special-purpose “application-specific” code to maximize reusability and flexibility.

**Real-world analogy**: A car engine (general-purpose) can be used in different vehicles (special-purpose). Mixing engine logic with car-specific features (like a sunroof) makes the engine harder to reuse.

---

## 9.5 Example: Insertion Cursor and Selection

It’s tempting to combine related concepts into one object for convenience, but this can complicate the API and make internal state harder to manage.

### Example: Text Editor Cursor and Selection
In a text editor, the cursor (where text is inserted) and the selection (highlighted text) are related but distinct.

**Poor Approach**: Combine them into one object:

```java
class TextEditor {
    Position cursorAndSelection; // Confusing mix of cursor and selection
}
```

**Problem**:
- The API is unclear: Does `cursorAndSelection` represent a single position or a range?
- Internal state is harder to reason about, as one object handles two responsibilities.

**Better Approach**: Keep them separate:

```java
class TextEditor {
    Position cursor;      // Where text will be inserted
    Selection selection;  // Two Positions (start and end of