# Chapter 5 — Information Hiding (and Leakage)

## 5.1 Information Hiding

The most important technique for achieving deep modules is **information hiding**.  
Each module should encapsulate a small set of important design decisions — implementation details that are invisible to other modules.  
This is not just about making variables or methods private; it’s about ensuring that other modules **don’t need to know** how things are done internally.

When you hide information:

1. **Interfaces become simpler.** Callers see only the abstract capabilities, not the messy details.
2. **The system is easier to change.** Implementation changes don’t ripple through the codebase.

Typical things worth hiding:

- How a data structure stores and retrieves information.
- How a file format is structured.
- How a protocol is implemented.
- How certain performance optimizations work.

### Bad Example — Database Details Leaked

```js
function saveUser(user) {
  const sql = `INSERT INTO users (name) VALUES ('${user.name}')`; // SQL leaked
  db.query(sql);
}

function getUser(id) {
  const sql = `SELECT * FROM users WHERE id = ${id}`; // SQL leaked
  return db.query(sql);
}
```

- SQL syntax and schema knowledge are spread across multiple functions.
- Any schema change requires touching every function.

### Better Example — Database Encapsulated

```js
class UserRepository {
  save(user) {
    /* SQL hidden here */
  }
  findById(id) {
    /* SQL hidden here */
  }
}
```

- All database knowledge is in **one place**.
- Callers use `save()` and `findById()` without knowing the underlying storage.

### Why It’s Better

- Callers deal only with a stable, minimal API.
- The implementation can change without breaking users.
- Less duplicated knowledge → fewer bugs.

---

## 5.2 Information Leakage

The opposite of information hiding is **information leakage** — when the same knowledge appears in multiple modules.  
This creates a dependency: if the knowledge changes, **every place it appears must change**.  
Sometimes leakage is obvious, but often it’s subtle, buried in code rather than interfaces.

### Bad Example — File Path Logic Duplicated

```js
// fileReader.js
function readUser(id) {
  const path = `/data/${id}.json`; // duplicated
  return JSON.parse(fs.readFileSync(path, "utf-8"));
}

// fileWriter.js
function writeUser(user) {
  const path = `/data/${user.id}.json`; // duplicated
  fs.writeFileSync(path, JSON.stringify(user));
}
```

- Path-building logic is repeated.
- If the directory changes, both functions break.

### Better Example — Centralized Path Logic

```js
class UserStore {
  static filePath(id) {
    return `/data/${id}.json`;
  }
  read(id) {
    return JSON.parse(fs.readFileSync(UserStore.filePath(id), "utf-8"));
  }
  write(user) {
    fs.writeFileSync(UserStore.filePath(user.id), JSON.stringify(user));
  }
}
```

- Path logic is defined once in `filePath()`.
- Any change is made in a single place.

### Why It’s Better

- Reduces maintenance cost.
- Prevents inconsistencies.
- Keeps related knowledge together.

---

## 5.3 Temporal Decomposition

A common cause of leakage is **temporal decomposition** — organizing code by execution order instead of by responsibility.  
This often forces multiple modules to know the same details.

### Bad Example — HTTP Request Handling

```js
class HttpReader {
  read(socket) {
    /* raw HTTP string */
  }
}

class HttpParser {
  parse(raw) {
    /* needs HTTP knowledge */
  }
}
```

- Both classes must understand HTTP structure.
- Parsing logic could be duplicated.

### Better Example — Unified Request Handling

```js
class HttpRequest {
  static fromSocket(socket) {
    const raw = socket.read();
    return new HttpRequest(raw); // parses internally
  }
  constructor(raw) {
    this.method = ... // parse method
    this.headers = ... // parse headers
    this.body = ... // parse body
  }
}
```

- All HTTP request knowledge is in **one module**.
- Callers simply call:

```js
const req = HttpRequest.fromSocket(socket);
```

### Why It’s Better

- Prevents duplication of parsing knowledge.
- Reduces the number of moving parts.
- Callers don’t have to remember sequencing rules.

---

## 5.4 Internal Data Structure Leakage

Another form of leakage is returning internal data structures directly.  
This exposes the representation and makes it hard to change without breaking callers.  
It can also lead to accidental state corruption.

### Bad Example — Params Object Exposed

```js
class HttpRequest {
  constructor() {
    this.params = { id: "123", page: "2" };
  }
  getParams() {
    return this.params;
  }
}
```

- Callers can modify internal state:

```js
req.getParams().id = "999";
```

- Changing storage from object → `Map` breaks API.

### Better Example — Accessor Methods

```js
class HttpRequest {
  getParameter(name) {
    /* return decoded value */
  }
  getIntParameter(name) {
    /* parse as int */
  }
}
```

- Callers can’t corrupt state.
- Internal storage can change freely.

### Why It’s Better

- Freedom to change implementation.
- Stronger guarantees for callers.
- Cleaner, more obvious API.

---

## 5.5 Defaults (Partial Information Hiding)

Defaults simplify APIs by handling common values automatically.  
They hide unnecessary details from most callers, while still allowing overrides when needed.

### Bad Example — Manual HTTP Response Setup

```js
class HttpResponse {
  constructor(version, date) {
    this.version = version;
    this.date = date;
  }
}

const res = new HttpResponse("HTTP/1.1", new Date().toUTCString());
```

- Callers must always supply version and date.
- Encourages duplication.

### Better Example — Automatic Defaults

```js
class HttpResponse {
  constructor(request) {
    this.version = request.version; // auto
    this.date = new Date().toUTCString(); // auto
  }
}
```

- Common values are set automatically.
- Still allows:

```js
res.version = "HTTP/2";
```

### Even Better — Optional Overrides

```js
class HttpResponse {
  constructor(request, options = {}) {
    this.version = options.version ?? request.version;
    this.date = options.date ?? new Date().toUTCString();
  }
}
```

- Common case: automatic.
- Rare case: caller can override.

### Why It’s Better

- Reduces repetition.
- Prevents leaking protocol details.
- Lowers the chance of errors.

---

## 5.6 Summary

Information hiding is a cornerstone of deep modules:

- Keep related knowledge in one place.
- Avoid duplication of design details across modules.
- Don’t split code by time order if it causes shared knowledge to spread.
- Never expose internal structures directly.
- Use sensible defaults to simplify common cases.
