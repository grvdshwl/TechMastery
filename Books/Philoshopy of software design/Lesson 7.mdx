# Chapter 7 — Different Layer, Different Abstraction (Detailed Guide)

## 7.1 Pass‑Through Methods

### Core Idea

In a layered system, each layer should **do something different** from the layer below it.  
If a method **just calls another method with the same parameters** and does nothing else, it’s called a **pass‑through method**.

Pass‑through methods:

- **Don’t add any new value**.
- **Increase maintenance cost** (two methods to update instead of one).
- **Confuse responsibilities** — it’s not clear which class “owns” the feature.

### Bad Example — Shallow Layer

```js
class TextDocument {
  constructor(textArea) {
    this.textArea = textArea;
  }

  insertText(text, position) {
    // just passes through
    this.textArea.insertText(text, position);
  }

  getCursorPosition() {
    // just passes through
    return this.textArea.getCursorPosition();
  }
}

class TextArea {
  insertText(text, position) {
    /* real logic */
  }
  getCursorPosition() {
    /* real logic */
  }
}
```

**Why it’s bad:**

- `TextDocument` adds **no extra behavior**.
- Any time `TextArea` changes, `TextDocument` might also have to change.
- Two places to learn instead of one.

### Better Example — Remove the Middleman

```js
// Just use TextArea directly
const textArea = new TextArea();
textArea.insertText("Hello", 0);
```

OR move the real logic into `TextDocument` if that’s where it belongs:

```js
class TextDocument {
  insertTextAtCursor(text) {
    const cursor = this.getCursorPosition();
    // now this class owns the logic
    this.text.insertText(text, cursor);
  }
}
```

**Why it’s better:**

- Fewer places to update.
- Clearer **ownership** — you know which class handles the logic.
- Less duplication of method names.

**Red Flag:**

> If a method exists only to call another method with the same arguments, you probably don’t need it.

---

## 7.2 When Duplication Is Fine

Sometimes **two layers can have the same method name** — but only when each layer adds **real value**.

### Good Example — Dispatcher

```js
class RequestRouter {
  route(path, req, res) {
    if (path.startsWith("/api")) {
      return this.apiHandler(req, res);
    }
    if (path.startsWith("/static")) {
      return this.staticHandler(req, res);
    }
    return this.notFoundHandler(req, res);
  }
}
```

Here:

- `route()` **decides which handler to call**.
- Same signature as handlers, but **adds routing logic**.

**Why this is fine:**

- It **does something meaningful** before calling the next layer.

---

## 7.3 Decorators

A **decorator** is a wrapper object that adds features to another object.  
Problem: Most decorators **repeat the same methods** as the object they wrap — lots of pass‑throughs for a little benefit.

### Bad Example — Shallow Decorator

```js
class LoggingArray {
  constructor(inner) {
    this.inner = inner;
  }

  push(item) {
    console.log("push:", item);
    return this.inner.push(item); // pass-through
  }

  pop() {
    console.log("pop");
    return this.inner.pop(); // pass-through
  }
}
```

**Issues:**

- Lots of boilerplate.
- Minimal new logic (just logging).
- More classes to maintain.

### Better Example — Integrate the Feature

```js
class LoggableArray extends Array {
  push(item) {
    console.log("push:", item);
    return super.push(item);
  }
}
```

**Why it’s better:**

- All behavior in **one place**.
- No extra wrapper class.
- Still adds logging, but no needless forwarding.

---

## 7.4 Interface vs. Implementation

Your **API** (public methods) should usually look **different** from your **internal data representation**.

### Bad Example — API Mirrors Storage

```js
class TextBuffer {
  getLine(index) {
    /* returns one line */
  }
  setLine(index, text) {
    /* replaces a line */
  }
}
```

- Internal storage is **line-based**, so API is also **line-based**.
- If you want to insert text **in the middle of a line**, you must split and rejoin lines manually.

### Better Example — API Hides Storage

```js
class TextBuffer {
  insert(position, text) {
    /* can span lines */
  }
  delete(start, end) {
    /* range delete */
  }
}
```

- Still stores lines internally.
- API lets callers work in **positions**, not lines.
- Splitting/joining handled **inside the class**.

**Why it’s better:**

- Higher‑level code is simpler.
- Storage format can change without breaking API.
- API is more flexible.

---

## 7.5 Pass‑Through Variables

A **pass‑through variable** is a parameter passed down through many functions just so a deep function can use it.  
Forces **every method** in the chain to know about it.

### Bad Example — Passing Down Unused

```js
function main(cert) {
  runCommand(cert);
}

function runCommand(cert) {
  doStepOne(cert);
}

function doStepOne(cert) {
  connectSecure(cert);
}
```

- Each function **must** accept `cert` even if it doesn’t use it.
- Changing `cert` means changing many signatures.

### Better Example — Context Object

```js
class Context {
  constructor({ cert }) {
    this.cert = cert;
  }
}

function main() {
  const context = new Context({ cert: "myCert" });
  runCommand(context);
}

function doStepOne(context) {
  connectSecure(context.cert);
}
```

**Why it’s better:**

- All shared state is in **one object**.
- Adding more shared state doesn’t require changing many signatures.
- Easier to test.

**Note:** Context objects can become **dumping grounds** — keep them organized.

---

## 7.6 Key Takeaways

- **Each layer should do something different** from the one below it.
- Avoid **pass‑through methods** — they add no value.
- Only duplicate APIs if each layer **adds meaningful logic**.
- Be careful with **decorators** — don’t wrap just for the sake of wrapping.
- Hide your storage details — API should be **more abstract**.
- Avoid **pass‑through variables** — use context objects.
