// Step-by-step prep plan (so you actually improve)
// Lay your foundation (1–2 weeks). Refresh Big-O, arrays/strings, hash maps/sets, stacks/queues, sorting, recursion, trees/graphs, heaps, BFS/DFS, greedy, DP.

// Learn the patterns, not problems (2–4 weeks).
// Arrays & strings → sliding window / two pointers
// Searching/sorting → partitioning, binary search on answer
// Graphs → BFS/DFS/topo sort/Union-Find
// Trees → recursion, traversal, BST invariants
// Heaps → “top-k” and interval merging
// DP → knapsack/paths/partitioning templates

// Deliberate reps. 1–2 problems per pattern/day. After each, write a 3–5 line “takeaway” (when to use this pattern, common pitfalls).

// Timed mocks + voice-over. 40–45 minutes per problem, talk out loud. Record and review: did you clarify, propose brute force, iterate, test?

// Error log. Track misses: wrong DS choice, off-by-one, null handling, complexity math, etc. Re-attempt weekly until clean.

// Behavioral & design. Prepare STAR stories; review system-design basics (APIs, consistency, caching, queues, DB trade-offs).

// Step-by-step method to solve a coding question in the interview
// Restate & example. Confirm you understand; make a small example and expected output.

// Clarify constraints. Input size, ranges, duplicates, ordering, memory/time targets.

// State a brute force. Earn partial credit; set a baseline.

// Identify a pattern. “This smells like sliding window/heap/graph…”

// Outline algorithm verbally. High-level steps; get buy-in before coding.

// Code carefully. Small function, clean names, check null/edge inputs.

// Test by hand. Walk through your earlier example; hit edge cases.

// Analyze complexity. Time/space; mention trade-offs or variants.
