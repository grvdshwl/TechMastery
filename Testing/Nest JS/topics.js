// 🧱 Fundamentals of Testing in NestJS

// 1. What is Unit Testing?
// 2. Difference between Unit, Integration, and E2E Testing
// 3. Introduction to Jest (default test runner in NestJS)
// 4. NestJS Testing Utilities (@nestjs/testing)
// 5. Structure of a test file (e.g. .spec.ts)
// 6. Lifecycle hooks: beforeEach, afterEach, etc.

// 🔧 Service Testing

// 7. Testing Services with Dependencies
// 8. Mocking Dependencies using Jest Mocks
// 9. Using TestingModule for Unit Testing
// 10. Testing Async Functions in Services
// 11. Mocking HTTP Calls in Services

// 🎛️ Controller Testing

// 12. Testing NestJS Controllers
// 13. Mocking Request/Response Objects
// 14. Validating Request Payloads (DTOs)

// 🧪 Advanced Mocking Techniques

// 15. Using jest.spyOn for Spies
// 16. Creating Reusable Mock Factories
// 17. Using jest.fn() to simulate behaviors
// 18. Mocking Third-Party Libraries
// 19. Mocking NestJS Decorators (e.g. @Inject, @Get)

// 🛡️ Testing Guards, Pipes, and Interceptors

// 20. Unit Testing Custom Guards
// 21. Unit Testing Pipes (e.g. validation or transformation)
// 22. Unit Testing Interceptors (e.g. logging, caching)

// 🧩 Module-Level Testing

// 26. Testing NestJS Modules
// 27. Overriding Providers in Test Modules
// 28. Testing Global Middleware or Providers

// 🛠️ Tooling and Configuration

// 29. Configuring Jest (jest.config.js)
// 30. Generating Coverage Reports
// 31. Using ts-jest with TypeScript
// 32. Running Tests in Watch Mode (jest --watch)

// 🚀 Best Practices

// 33. Testing Naming Conventions
// 34. Avoiding Over-mocking
// 35. Writing Maintainable Tests
// 36. Test-Driven Development (TDD) in NestJS
// 37. Integrating Tests in CI/CD Pipelines
